# 課題１
## SOLID原則
### SRP:Single Responsibility Principle（単一責任の原則）
クラスの責務は1つにすること、クラスを変更する理由は1つ以上存在してはならないということ

例えば受注クラス、発注クラス、メール送信クラスがあったとして、メール送信のメールアドレスが変更になったとする。
受注、発注、メールを全て同じクラスにしていた場合はインスタンス化したメールアドレスを受注、発注、メールのメソッドの中で
使用していた場合は、全部のメソッドの中で変更する必要がある。

受注、発注、メールのクラスを全て分けていた場合は、メールのクラスの中だけを変更し、受注と発注側のクラスで別々にインスタンス化を行えば変更する箇所はメールクラスだけで良くなるため、できる限り細かく部品化しましょうということ。

class OrderReceived
{
  public function __construct(Order $order Mail $mail)
  {
     $this->order = $order;
     $this->mail  = $mail;
  }
}

class Order
{
  echo 'hoge';
}

class Mail
{
  echo 'fuga';
}

のようにそれぞれ部品化して影響範囲を限定的にする

### OCP:Open Closed Principle(オープン・クローズドの原則)
ソフトウェアの構成要素は拡張に対して開いていて、修正に対して閉じていなければならないという原則

例えばポイントシステムに追加の要件が加わったときに、新しいクラスを加えるとする。
そのときに、既存の問題ないプログラムはそのままにしたい。

そこで既存のポイントシステムのクラスに手を加えずに新しい機能を追加していく。
これが「拡張に対して開いている」ということ。古いポイントシステムのクラスはいじらない。

「修正に対して閉じている」とは古いポイントシステムクラスに変更があった場合に
古いポイントシステムクラスのみを変更すれば修正完了となること。

クラスを継承するやり方は良くない。スーパークラスの中身を全て見ないと行けないので時間がかかる。
その場合は古いポイントシステムと新しいポイントシステムのインターフェースを作る必要がある。

class OldPoint implements Card
{

}

class NewPoint implements Card
{

}

interface Card
{
  $kocomoCard = 1 * 1.1;
  $pokekeCard = 1 * 2.2;

  // クラスの中を書き換えるのではなく、インターフェース内で完結させてクラスはそのままにする
}

上記がオープンクローズドの原則

### L:Liskov Substitution Principle(リスコフの置換原則)
子クラスが親クラスと同じ動作を実行できない場合、バグになる可能性がある。

クラスから別のクラスを作ると、クラスが親になり、新しいクラスが子になる。子クラスは、親クラスができることを全てできる必要がある。
このプロセスを継承と呼ぶ。


class pikatyu extends raityu
{

}

class raityu
{

}

ピカチュウクラスはライチュウクラスを継承している。
つまり、ライチュウはピカチュウの技を全て使用できる。だが、逆はできない。

子クラスが大きく変更されて親クラスの内容を使用できなければ、リスコフの置換原則に違反する

### I:Interface Segregation Principle(インターフェイス分離の原則)
クライアントが使用しないメソッドへの依存を強制すべき




## 単一責任の原則と、単純にファイルを細かなファイルに分解することには、どのような違いがあるでしょうか？
ファイルを分割したとしても、例えば各ファイルに「銀行口座」クラスが書いてあったら責務バラバラになってしまう。
AファイルにもBファイルにもCファイルにもA銀行の口座情報が書いてあればそれだけ変更しなければならない。

単一責任の原則はクラスの責務は一つにすることなので、「銀行口座」クラスがありAファイルにA銀行の口座
 BファイルにB銀行の口座、CファイルにC銀行の口座のように一つのクラスの変更は一つのクラスが責任を持つ

## Open-Closed-Principleの実例を一つ考えて、作成してみてください。
